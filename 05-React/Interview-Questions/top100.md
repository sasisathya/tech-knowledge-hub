# React.js – 100 Interview Questions & Answers

> Comprehensive React interview preparation for SD3 / SD4 / FAANG-level roles

---

## 1. React Basics (1–15)

**1. What is React?**  
React is a JavaScript library for building UI using component-based architecture and Virtual DOM.

**2. Why use React?**  
Reusability, fast rendering via Virtual DOM, unidirectional data flow, strong ecosystem.

**3. What is JSX?**  
JSX is syntax sugar that allows writing HTML-like code in JavaScript, transpiled by Babel.

**4. Is JSX mandatory?**  
No, React can be written using `React.createElement()`.

**5. What is a component?**  
Reusable UI block; functional or class-based.

**6. Functional vs Class components?**  
Functional components use hooks; class components use lifecycle methods.

**7. What is Virtual DOM?**  
In-memory representation of the real DOM.

**8. How does React update the DOM?**  
Using diffing algorithm and reconciliation.

**9. What is reconciliation?**  
Process of comparing old and new Virtual DOM trees.

**10. What are props?**  
Read-only data passed from parent to child.

**11. What is state?**  
Mutable data managed inside a component.

**12. Props vs State?**  
Props are immutable; state is mutable.

**13. What is key in React?**  
Unique identifier for list items.

**14. Can index be used as key?**  
Not recommended for dynamic lists.

**15. What is React.Fragment?**  
Returns multiple elements without extra DOM nodes.

---

## 2. Hooks (16–35)

**16. What are hooks?**  
Functions that enable state and lifecycle features in functional components.

**17. useState?**  
Manages local component state.

**18. useEffect?**  
Handles side effects like API calls and subscriptions.

**19. Dependency array in useEffect?**  
Controls when the effect runs.

**20. useEffect cleanup?**  
Used to clean timers or subscriptions.

**21. useRef?**  
Access DOM elements or persist mutable values.

**22. useMemo?**  
Memoizes expensive calculations.

**23. useCallback?**  
Memoizes function references.

**24. useMemo vs useCallback?**  
useMemo returns value; useCallback returns function.

**25. useContext?**  
Consumes context values without prop drilling.

**26. Custom hooks?**  
Reusable logic built using hooks.

**27. Rules of hooks?**  
Call at top level, inside React functions only.

**28. Can hooks be conditional?**  
No.

**29. useLayoutEffect?**  
Runs synchronously after DOM updates.

**30. When to use useLayoutEffect?**  
DOM measurements and layout changes.

**31. useReducer?**  
Manages complex state logic.

**32. Why useReducer?**  
Predictable state transitions.

**33. useImperativeHandle?**  
Customize ref exposure.

**34. useId?**  
Generate unique IDs for accessibility.

**35. useTransition?**  
Mark non-urgent updates.

---

## 3. Component Lifecycle (36–45)

**36. Mounting phase?**  
constructor → render → componentDidMount

**37. Updating phase?**  
render → componentDidUpdate

**38. Unmounting phase?**  
componentWillUnmount

**39. getDerivedStateFromProps?**  
Sync state with props.

**40. shouldComponentUpdate?**  
Optimizes rendering.

**41. componentDidCatch?**  
Handles errors.

**42. Error boundaries?**  
Catch rendering errors.

**43. Hooks alternative to lifecycle methods?**  
useEffect.

**44. Can hooks replace all lifecycle methods?**  
Yes, except error boundaries.

**45. Why error boundaries don’t catch async errors?**  
They catch render-phase errors only.

---

## 4. Performance Optimization (46–60)

**46. How to optimize React apps?**  
Memoization, code splitting, virtualization.

**47. React.memo?**  
Prevents unnecessary re-renders.

**48. When React.memo fails?**  
When props are new references.

**49. Why immutability matters?**  
Enables shallow comparison.

**50. Lazy loading?**  
Load components on demand.

**51. Suspense?**  
Fallback UI for lazy components.

**52. Code splitting?**  
Break bundle into chunks.

**53. Virtualized lists?**  
Render visible items only.

**54. Debounce vs throttle?**  
Debounce delays; throttle limits frequency.

**55. Avoid inline functions?**  
Yes, for performance.

**56. Avoid anonymous components?**  
Yes, improves debugging.

**57. Why keys important?**  
Avoid DOM recreation.

**58. Batch updates?**  
Groups state updates.

**59. Concurrent rendering?**  
Interruptible rendering.

**60. StrictMode?**  
Highlights unsafe practices.

---

## 5. State Management (61–70)

**61. Lifting state up?**  
Move shared state to parent.

**62. Prop drilling?**  
Passing props through many layers.

**63. Context API?**  
Global state sharing.

**64. Redux vs Context?**  
Redux for complex state.

**65. Redux principles?**  
Single store, immutability, pure reducers.

**66. Redux middleware?**  
Extends Redux (Thunk, Saga).

**67. Redux Toolkit?**  
Opinionated Redux setup.

**68. Zustand / Recoil?**  
Lightweight state management.

**69. When NOT to use Redux?**  
Small applications.

**70. Server vs UI state?**  
API data vs UI controls.

---

## 6. Routing (71–78)

**71. React Router?**  
Client-side routing library.

**72. BrowserRouter vs HashRouter?**  
History API vs hash URLs.

**73. useParams?**  
Access route parameters.

**74. useNavigate?**  
Programmatic navigation.

**75. Nested routes?**  
Routes inside routes.

**76. Protected routes?**  
Authentication-based routing.

**77. Lazy routes?**  
Route-level code splitting.

**78. 404 handling?**  
Wildcard routes.

---

## 7. Forms & Events (79–85)

**79. Controlled components?**  
Form value controlled by state.

**80. Uncontrolled components?**  
Uses refs.

**81. Synthetic events?**  
Cross-browser event wrapper.

**82. Event pooling?**  
Reusing event objects.

**83. Prevent default?**  
Stops browser behavior.

**84. Form validation?**  
Manual or libraries.

**85. File uploads?**  
Using input and FormData.

---

## 8. Testing & Best Practices (86–100)

**86. React Testing Library?**  
Tests UI behavior.

**87. Jest?**  
JavaScript testing framework.

**88. Snapshot testing?**  
Compare rendered output.

**89. Why avoid snapshot overuse?**  
Brittle tests.

**90. Testing hooks?**  
Using renderHook.

**91. Folder structure?**  
Feature-based.

**92. Smart vs dumb components?**  
Logic vs presentation.

**93. Higher-Order Components?**  
Component wrappers.

**94. Render props?**  
Function as child.

**95. Accessibility?**  
ARIA roles, labels.

**96. SEO issue in React?**  
CSR limitations.

**97. SSR solution?**  
Next.js.

**98. Hydration?**  
Attach events to SSR HTML.

**99. Micro-frontends?**  
Independent UI deployments.

**100. When NOT to use React?**  
Simple static pages.

---